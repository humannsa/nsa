{
  "name": "ChartTime",
  "description": "Hierarchical time-series axis for charts with knockouts for holidays, weekends, and lots of other conveniences.",
  "keywords": [
    "charting",
    "chart",
    "infographics",
    "date",
    "time"
  ],
  "author": {
    "name": "Larry Maccherone",
    "url": "http://maccherone.com"
  },
  "version": "0.1.0",
  "homepage": "https://github.com/lmaccherone/ChartTime",
  "engines": {
    "node": ">=0.4.10"
  },
  "dependencies": {
    "coffee-script": ">=1.1.1"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/lmaccherone/ChartTime.git"
  },
  "preferGlobal": true,
  "devDependencies": {
    "coffeedoctest": ">=0.1.0"
  },
  "readme": "# ChartTime #\n\nCopyright (c) 2012, Lawrence S. Maccherone, Jr.\n\n_Time axis creation/manipulation for charts_\n\n## Credits ##\n\nAuthors:\n\n* [Larry Maccherone](http://maccherone.com) (Larry @at@ Maccherone .dot. com)\n* Jennifer Maccherone\n\nRunning:\n\n* [timezoneJS](https://github.com/mde/timezone-js) - library for [tz](http://www.twinsun.com/tz/tz-link.htm) parsing\n* [Node.js](http://nodejs.org/)\n* [CoffeeScript](http://coffeescript.org/)\n\nDeveloping/Documenting:\n\n* [coffeedoc](https://github.com/lmaccherone/coffeedoc) (Larry Maccherone's fork) forked from [coffeedoc](https://github.com/omarkhan/coffeedoc)\n* [coffeedoctest](https://github.com/lmaccherone/coffeedoctest) (by Larry Maccherone)\n* [nodeunit](https://github.com/caolan/nodeunit)\n\n## Documentation and source code ##\n\n* [API Documentation](http://lmaccherone.github.com/ChartTime/docs/ChartTime.html)\n* [github.com/lmaccherone/ChartTime](https://github.com/lmaccherone/ChartTime)\n\n## Features ##\n\n* Generate the values for time series chart axis\n* Allows for custom granularities like release/iteration/iteration_day\n* Knockout weekends and holidays\n* Knockout non-work hours\n* Drill up and down granularity (coneceptually supported by ChartTime, consumed by Lumenize)\n* Work with precision around timezone differences\n* Month is 1-indexed instead of 0-indexed like Javascript's Date object\n* Date/Time math (add 3 months, subtract 2 weeks, etc.)\n* Tested\n* Documented\n\n## Granularity ##\n\nEach ChartTime object has a granularity. This means that you never have to\nworry about any bits lower than your specified granularity. A day has only\nyear, month, and day segments. You are never tempted to specify 11:59pm\nto specify the end of a day-long timebox.\n\nChartTime supports the following granularities:\n\n* `year`\n    * `month`\n        * `day`\n            * `hour`\n               * `minute`\n                   * `second`\n                       * `millisecond`\n    * `quarter` (but not quarter_month, day, etc.)\n    * `week` (ISO-8601 style week numbering)\n       * `week_day` (Monday = 1, Sunday = 7)\n\nAlso, you can define your own custom hierarchical granularities, for example...\n\n* `release`\n   * `iteration`\n      * `iteration_day`\n  \n## Timezone precision ##\n\nIt's very hard to do filtering and grouping of time-series data with timezone precision. \n\nFor instance, 11pm in California on December 25 (Christmas holiday) is 2am December 26 (not a holiday)\nin New York. This also happens to be 7am December 26 GMT. If you have an event that occurs at \n2011-12-26T07:00:00.000Z, then you need to decide what timezone to use as your context before you \ndecide if that event occured on Christmas day or not. It's not just holidays, where this can burn you.\nDeciding if a piece of work finished in one iteration versus another can make a difference for\nyou iteration metrics. The iteration metrics for a distributed team should look the same regardless\nof whether it was generated in New York versus Los Angeles... versus Bangalore.\n\nThe javascript Date object lets you work in either the local time or Zulu (GMT/UTC) time but it doesn't let you\ncontrol the timezone. Do you know the correct way to apply the timezone shift to a JavaScript Date Object? \nDo you know when Daylight Savings Time kicks in and New York is 4 hours shifted from GMT instead of 5? Will\nyou remember to do it perfectly every time it's needed in your code?\n\nIf you need this precision, ChartTime helps by clearly delineating the moment when you need to do \ntimezone manipulation... the moment you need to compare two or more dates. You can do all of your\nholiday/weekend knockout manipulation without regard to timezone and only consider the timezone\nupon comparison. \n\n## Month is 1-indexed as you would expect ##\n\nJavascript's date object uses 0 for January and 11 for December. ChartTime uses 1 for January and 12 for December...\nwhich is what ISO-8601 uses and what humans expect. Everyone who works with the javascript Date Object at one\npoint or another gets burned by this.\n\n## Week support ##\n\nChartTime follows ISO-8601 where ever it makes sense. Implications of using this ISO format (paraphrased info from wikipedia):\n\n* All weeks have 7 days (i.e. there are no fractional weeks).\n* Any given day falls into a single week which means that incrementing across the year boundary in week\n  granularity is without gaps or repeats.\n* Weeks are contained within a single year. (i.e. weeks are never spit over two years).\n* The above two implications also mean that we have to warp the boundaries of the year to accomplish this. In week\n  granularity dates may appear in a different year than you would expect and some years have 53 weeks.\n* The date directly tells the weekday.\n* All years start with a Monday and end with a Sunday.\n* Dates represented as yyyyWww-d can be sorted as strings.\n\n**In general, it just greatly simplifies the use of week granularity in a chart situation.**\n\nThe only real downside to this approach is that USA folks expect the week to start on Sunday. However, the ISO-8601 spec starts\neach week on Monday. Following ISO-8601, ChartTime uses 1 for Monday and 7 for Sunday which aligns with\nthe US standard for every day except Sunday. The US standard is to use 0 for Sunday.\n\n## Basic usage ##\n\n    {ChartTime, ChartTimeIterator, ChartTimeRange} = require('charttime')\n    \n    d1 = new ChartTime({granularity: 'day', year: 2011, month: 2, day: 28})\n    console.log(d1.toString())\n    # 2011-02-28\n    \nYou can use the string short-hand rather than spell out the segments seperately. The granularity\nis automatically inferred from how many segments you provide.\n\n    d2 = new ChartTime('2011-03-01')\n    console.log(d2.toString())\n    # 2011-03-01\n    \nIncrement/decrement and compare ChartTimes without regard to timezone\n\n    console.log(d1.$gte(d2)) \n    d1.increment()\n    console.log(d1.$eq(d2))\n    # false\n    # true\n\nDo math on them.\n    \n    d3 = d1.add(5)\n    console.log(d3.toString())\n    # 2011-03-06\n\nGet the day of the week.\n\n    console.log(d3.dowString())\n    # Sunday\n    \nSubtraction is just addition with negative numbers.\n\n    d3.addInPlace(-6)\n    console.log(d3.toString())\n    # 2011-02-28\n\nIf you start on the last day of a month, adding a month takes you to the last day of the next month, \neven if the number of days are different.\n    \n    d3.addInPlace(1, 'month')  \n    console.log(d3.toString())\n    # 2011-03-31\n    \nDeals well with year-granularity math and leap year complexity.\n\n    d4 = new ChartTime('2004-02-29')  # leap day\n    d4.addInPlace(1, 'year')  # adding a year takes us to a non-leap year\n    console.log(d4.toString())\n    # 2005-02-28\n    \nWeek granularity correctly wraps and deals with 53-week years.\n\n    w1 = new ChartTime('2004W53-6')\n    console.log(w1.inGranularity('day').toString())\n    # 2005-01-01\n    \nConvert between any of the standard granularities. Also converts custom granularities (not shown) to\nstandard granularities if you provide a `rataDieNumber()` function with your custom granularities.\n\n    d5 = new ChartTime('2005-01-01')  # goes the other direction also\n    console.log(d5.inGranularity('week_day').toString())\n    # 2004W53-6\n    \n    q1 = new ChartTime('2011Q3')\n    console.log(q1.inGranularity('millisecond').toString())\n    # 2011-07-01T00:00:00.000\n    \n## Timezones ##\n\nChartTime does timezone sensitive conversions. You must set the path to the tz files before doing any timezone sensitive comparisons.\n\n    ChartTime.setTZPath('../vendor/tz')\n    \n    console.log(new ChartTime('2011-01-01').getJSDate('America/New_York'))\n    # Sat, 01 Jan 2011 05:00:00 GMT\n    \n## Iterating over ranges skipping weekends (non-workdays), holidays and non-workhours ##\n\n    r = new ChartTimeRange({\n      start: new ChartTime('2011-01-02'),\n      pastEnd: new ChartTime('2011-01-07'),\n      workDays: 'Monday, Tuesday, Thursday, Friday',  # very strange work week\n      holidays: [\n        {month: 1, day: 1},  # Notice the lack of a year specification\n        {year: 2011, month: 1, day: 3}  # Got January 3 off also in 2011\n      ]\n    })\n    \nNow let's get an iterator over this range.\n    \n    i = r.getIterator('ChartTime')\n    \n    while i.hasNext()\n      console.log(i.next().toString()) \n           \n    # 2011-01-04\n    # 2011-01-06\n\n# ChartTime utils #\nCopyright (c) Lawrence S. Maccherone, Jr., 2012\n",
  "readmeFilename": "README.md",
  "_id": "ChartTime@0.1.0",
  "dist": {
    "shasum": "b257f3f58e2c4c3522b645e93464b0b1f0f604c1"
  },
  "deprecated": "Use Lumenize. It has the ChartTime object and much more.",
  "_from": "ChartTime@",
  "_resolved": "https://registry.npmjs.org/ChartTime/-/ChartTime-0.1.0.tgz"
}
