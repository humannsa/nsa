var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        var y = cwd || '.';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = x + '/package.json';
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = Object_keys(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

require.define = function (filename, fn) {
    var dirname = require._core[filename]
        ? ''
        : require.modules.path().dirname(filename)
    ;
    
    var require_ = function (file) {
        return require(file, dirname)
    };
    require_.resolve = function (name) {
        return require.resolve(name, dirname);
    };
    require_.modules = require.modules;
    require_.define = require.define;
    var module_ = { exports : {} };
    
    require.modules[filename] = function () {
        require.modules[filename]._cached = module_.exports;
        fn.call(
            module_.exports,
            require_,
            module_,
            module_.exports,
            dirname,
            filename
        );
        require.modules[filename]._cached = module_.exports;
        return module_.exports;
    };
};

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

if (typeof process === 'undefined') process = {};

if (!process.nextTick) process.nextTick = function (fn) {
    setTimeout(fn, 0);
};

if (!process.title) process.title = 'browser';

if (!process.binding) process.binding = function (name) {
    if (name === 'evals') return require('vm')
    else throw new Error('No such module')
};

if (!process.cwd) process.cwd = function () { return '.' };

require.define("path", function (require, module, exports, __dirname, __filename) {
    function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

});

require.define("/ChartTime.coffee", function (require, module, exports, __dirname, __filename) {
    (function() {

  /*
  # ChartTime #
  Copyright (c) Lawrence S. Maccherone, Jr., 2012
  
  Time axis creation/manipulation for charts.
  
  Features:
  
  * Generate the values for time series chart axis
  * Allows for custom granularities like release/iteration/iteration_day
  * Knockout weekends and holidays
  * Knockout non-work hours
  * Drill up and down granularity (coneceptually supported by ChartTime, consumed by Lumenize)
  * Work with precision around timezone differences
  * Month is 1-indexed instead of 0-indexed like Javascript's Date object
  * Date/Time math (add one month, subtract 2 weeks, etc.)
  * Tested
  * Documented
  
  ## Granularity ##
  Each ChartTime object has a granularity. This means that you never have to
  worry about any bits lower than your specified granularity. A day has only
  year, month, and day segments. You are never tempted to specify 11:59pm
  to specify the end of a day-long timebox.
  
  ChartTime supports the following granularities:
  
  * `year`
      * `month`
          * `day` (most well tested)
              * `hour`
                 * `minute`
                     * `second`
                         * `millisecond`
  * `quarter` (need to upgrade to support quarter_month, day, ...)
  * `week` (ISO-8601 style week numbering)
     * `week_day` (Monday = 1, Sunday = 7)
  
  Also, you can define your own custom hierarchical granularities, for example...
  
  * `release`
     * `iteration`
        * `iteration_day`
    
  ## Time zone precision ##
  It's much less error prone to do day filtering and manipulation without regard to timezone. 
  For instance, 11pm in California on December 25 (Christmas holiday) is 2am December 26 (not a holiday)
  in New York. This also happens to be 7am December 26 GMT. If you have an event that occurs at 
  2011-12-26T07:00:00.000Z, then you need to decide what timezone to use as your context before you 
  decide if that event occured on Christmas day or not. It's not just holidays, where this can burn you.
  Deciding if a piece of work finished in one iteration versus another can make a difference for
  you iteration metrics. The iteration metrics for a distributed team should look the same regardless
  of whether it was generated in New York versus Los Angeles... versus Bangalore.
  
  The javascript Date object lets you work in either the local time or Zulu (GMT/UTC) time but it doesn't let you
  control the timezone. Do you know the correct way to apply the timezone shift to a JS object? Will
  you remember to do it perfectly every time it's needed in your code?
  
  If you need this precision, ChartTime helps by clearly delineating the moment when you need to do 
  timezone manipulation... upon construction of a new ChartTime object. Once you have it in the correct 
  timezone context, ChartTime drops the timezone information and lets you work without that complexity. 
  
  The intention for ChartTime is to add support for converting to a timezone context upon construction, but
  at this point, you must do that yourself before creating a ChartTime object. I have added timezone-js to
  the project and started playing with it so we may have that soon.
  
  ## Month is 1-indexed as you would expect ##
  Javascript's date object uses 0 for January and 11 for December. ChartTime uses 1 for January and 12 for December...
  which is what ISO-8601 uses and what humans expect.
  
  ## Week support ##
  
  For the day of the week (`week_day`), ChartTime uses 1 for Monday and 7 for Sunday just like ISO-8601. ChartTime 
  follows ISO-8601 where ever it makes sense.
  
  Implications of using this ISO format over the US and other approaches that start the week on Sunday with a value
  of 0: (summarized with info from wikipedia)
  
  * All weeks have 7 days (i.e. there are no fractional weeks).
  * Weeks are contained within a single year. (i.e. weeks are never spit over two years)... although we have to 
    warp the boundaries of the year to accomplish this and some years have 53 weeks.
  * The date directly tells the weekday.
  * All years start with a Monday and end with a Sunday.
  * Dates represented as yyyyWww-d can be sorted as strings.
  
  **In general, it just greatly simplifies the use of week granularity in a chart situation.**
  
  The biggest downside to this approach is that USA folks expect the week to start on Sunday. 
  
  ## Usage ##
  
      ChartTime = require('charttime').ChartTime
      
      d1 = new ChartTime({granularity: 'day', year: 2011, month: 2, day: 28})
      console.log(d1.toString())
      # 2011-02-28
      
      d2 = new ChartTime('2011-03-01')
      console.log(d2)
      # { granularity: 'day', year: 2011, month: 3, day: 1 }
      
      console.log(d1.$gte(d2))  # also has $lt, $lte, and $gt
      d1.increment()
      console.log(d1.$eq(d2))
      # false
      # true
      
      d3 = d1.add(5)
      console.log(d3.toString())
      console.log(d3.dowString())
      # 2011-03-06
      # Sunday
      
      d3.addInPlace(-6)
      console.log(d3.toString())
      # 2011-02-28
      
      d3.addInPlace(1, 'month')  # adding a month takes you to the last day of the next month
      console.log(d3.toString())
      # 2011-03-31
      
      d4 = new ChartTime('2004-02-29')  # leap day
      d4.addInPlace(1, 'year')  # non-leap year
      console.log(d4.toString())
      # 2005-02-28
      
      w1 = new ChartTime('2004W53-6')  # deals with 53-week years
      console.log(w1.inGranularity('day').toString())
      # 2005-01-01
      
      d5 = new ChartTime('2005-01-01')  # goes the other direction also
      console.log(d5.inGranularity('week_day').toString())
      # 2004W53-6
      
      q1 = new ChartTime('2011Q3')
      console.log(q1.inGranularity('millisecond').toString())
      # 2011-07-01T00:00:00.000
      
  ## Documentation ##
  
  The API for ChartTime is fully documented (using coffeedoc) in the docs folder.
  */

  var ChartTime, ChartTimeIterator, timezoneJS, utils;
  var __hasProp = Object.prototype.hasOwnProperty, __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (__hasProp.call(this, i) && this[i] === item) return i; } return -1; };

  utils = require('./utils');

  timezoneJS = require('timezone-js').timezoneJS;

  ChartTime = (function() {
    var g, spec, _ref;

    ChartTime.granularitySpecs = {};

    ChartTime.granularitySpecs['millisecond'] = {
      segments: ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'],
      mask: '####-##-##T##:##:##.###',
      lowest: 0,
      pastHighest: function() {
        return 1000;
      }
    };

    ChartTime.granularitySpecs['second'] = {
      segments: ['year', 'month', 'day', 'hour', 'minute', 'second'],
      mask: '####-##-##T##:##:##',
      lowest: 0,
      pastHighest: function() {
        return 60;
      }
    };

    ChartTime.granularitySpecs['minute'] = {
      segments: ['year', 'month', 'day', 'hour', 'minute'],
      mask: '####-##-##T##:##',
      lowest: 0,
      pastHighest: function() {
        return 60;
      }
    };

    ChartTime.granularitySpecs['hour'] = {
      segments: ['year', 'month', 'day', 'hour'],
      mask: '####-##-##T##',
      lowest: 0,
      pastHighest: function() {
        return 24;
      }
    };

    ChartTime.granularitySpecs['day'] = {
      segments: ['year', 'month', 'day'],
      mask: '####-##-##',
      lowest: 1,
      pastHighest: function(ct) {
        return ct.daysInMonth() + 1;
      }
    };

    ChartTime.granularitySpecs['month'] = {
      segments: ['year', 'month'],
      mask: '####-##',
      lowest: 1,
      pastHighest: function() {
        return 12 + 1;
      }
    };

    ChartTime.granularitySpecs['year'] = {
      segments: ['year'],
      mask: '####',
      lowest: 1,
      pastHighest: function() {
        return 9999 + 1;
      }
    };

    ChartTime.granularitySpecs['week'] = {
      segments: ['year', 'week'],
      mask: '####W##',
      lowest: 1,
      pastHighest: function(ct) {
        if (ct.is53WeekYear()) {
          return 53 + 1;
        } else {
          return 52 + 1;
        }
      }
    };

    ChartTime.granularitySpecs['week_day'] = {
      segments: ['year', 'week', 'week_day'],
      mask: '####W##-#',
      lowest: 1,
      pastHighest: function(ct) {
        return 7 + 1;
      }
    };

    ChartTime.granularitySpecs['quarter'] = {
      segments: ['year', 'quarter'],
      mask: '####Q#',
      lowest: 1,
      pastHighest: function() {
        return 4 + 1;
      }
    };

    ChartTime.expandMask = function(granularitySpec) {
      var char, i, mask, segmentEnd;
      mask = granularitySpec.mask;
      if (mask != null) {
        if (mask.indexOf('#') >= 0) {
          i = mask.length - 1;
          while (mask[i] !== '#') {
            i--;
          }
          segmentEnd = i;
          while (mask[i] === '#') {
            i--;
          }
          granularitySpec.segmentStart = i + 1;
          granularitySpec.segmentLength = segmentEnd - i;
          return granularitySpec.regex = new RegExp(((function() {
            var _i, _len, _ref, _results;
            _ref = mask.split('');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              char = _ref[_i];
              _results.push(char === '#' ? '\\d' : char);
            }
            return _results;
          })()).join(''));
        } else {
          return granularitySpec.regex = new RegExp(mask);
        }
      }
    };

    _ref = ChartTime.granularitySpecs;
    for (g in _ref) {
      spec = _ref[g];
      ChartTime.expandMask(spec);
    }

    ChartTime.addGranularity = function(granularitySpec) {
      /*
          addGranularity allows you to add your own hierarchical to ChartTime and initiate those ChartTime object in your newly specified
          granularity. You specify new granularities with granularitySpec object like this:
          
              granularitySpec = {
                release: {
                  mask: 'R##',
                  lowest: 1,
                  timeBoxes: [
                    {}, # To make it so lowest can be 1 instead of 0
                    {start: new ChartTime('2011-01-01'), pastEnd: new ChartTime('2011-04-01'), label: 'Release 1'},
                    {start: new ChartTime('2011-04-01'), pastEnd: new ChartTime('2011-07-01'), label: 'Release 2'}
                  ]
                  pastHighest: (ct) ->
                    return ChartTime.granularitySpecs.release.timeBoxes.length 
                  rataDieNumber: (ct) ->
                    return ChartTime.granularitySpecs.release.timeBoxes[ct.release].start.rataDieNumber()
                },
                iteration: {
                  segments: ['release', 'iteration'],
                  mask: 'R##I##',
                  lowest: 1,
                  timeBoxes: [
                    [],  # To make it 1-indexed
                    [
                      {},  # To make it 1-indexed
                      {start: new ChartTime('2011-01-01'), pastEnd: new ChartTime('2011-02-01'), label: 'R1 Iteration 1'},
                      {start: new ChartTime('2011-02-01'), pastEnd: new ChartTime('2011-03-01'), label: 'R1 Iteration 2'},
                      {start: new ChartTime('2011-03-01'), pastEnd: new ChartTime('2011-04-01'), label: 'R1 Iteration 3'},
                    ],
                    [
                      {},
                      {start: new ChartTime('2011-04-01'), pastEnd: new ChartTime('2011-05-01'), label: 'R2 Iteration 1'},
                      {start: new ChartTime('2011-05-01'), pastEnd: new ChartTime('2011-06-01'), label: 'R2 Iteration 2'},
                      {start: new ChartTime('2011-06-01'), pastEnd: new ChartTime('2011-07-01'), label: 'R2 Iteration 3'},
                    ]
                  ]
                  pastHighest: (ct) ->
                    return ChartTime.granularitySpecs.iteration.timeBoxes[ct.release].length 
                  rataDieNumber: (ct) ->
                    return ChartTime.granularitySpecs.iteration.timeBoxes[ct.release][ct.iteration].start.rataDieNumber()
                },
                iteration_day: {  # By convention, it knows to use day functions on it. This is the lowest allowed custom granularity
                  segments: ['release', 'iteration', 'iteration_day'],
                  mask: 'R##I##-##',
                  lowest: 1,
                  pastHighest: (ct) ->
                    iterationTimeBox = ChartTime.granularitySpecs.iteration.timeBoxes[ct.release][ct.iteration]
                    return iterationTimeBox.pastEnd.rataDieNumber() - iterationTimeBox.start.rataDieNumber() + 1
                  rataDieNumber: (ct) ->
                    return ChartTime.granularitySpecs.iteration.timeBoxes[ct.release][ct.iteration].start.rataDieNumber() + ct.iteration_day - 1
                }
              }   
              ChartTime.addGranularity(granularitySpec)
      
          
          The `mask` must cover all of the segments to get down to the granularity being specified. The digits of the granularity segments
          are represented with `#`. Any other characters can be used as a delimeter, but it should always be one character to comply with 
          the expectations of the Lumenize hierarchy visualizations. All of the standard granularities start with a 4-digit year so to
          distinguish your custom granularity, your highest level must start with some number of digits other than 4 or a prefix letter 
          (like the `R`, `I`, and `-` in the example above. I used `-` in the example above as the delimiter before the `iteration_day`
          granularity but you could have used any character.
          
          In order for the ChartTimeIterator to work, you must provide `pastHighest` and `rataDieNumber` callback functions. You should
          be able to mimic (or use as-is) the example above for most use cases. Notice how the `rataDieNumber` function simply leverages
          `rataDieNumber` functions for the standard granularities.
          
          In order to convert into this granularity from some other granularity, you must provide an `inGranularity` callback [NOT YET IMPLEMENTED].
          
          **The `timeBoxes` propoerty in the configuration object has no special meaning** to ChartTime or ChartTimeIterator. It's simply used
          by the `pastHighest` and `rataDieNumber` functions. The boundaries could come from whereever you want and even have been encoded in
          one of the required callback functions.
          
          The convention of naming the lowest order granularity with `_day` at the end is signficant. It knows to treat that as a day-level
          granularity. If there is a use-case for it, ChartTime could be upgraded to allow you to drill down into hours, minutes, etc. from any
          `_day` granularity but right now those lower order time granularities are only supported for the canonical form.
      */
      var g, spec, _results;
      _results = [];
      for (g in granularitySpec) {
        spec = granularitySpec[g];
        ChartTime.expandMask(spec);
        _results.push(this.granularitySpecs[g] = spec);
      }
      return _results;
    };

    function ChartTime(spec_RDN_Or_String, granularity) {
      var rdn, s;
      this.beforePastFlag = '';
      switch (utils.type(spec_RDN_Or_String)) {
        case 'string':
          s = spec_RDN_Or_String;
          this.setFromString(s, granularity);
          break;
        case 'number':
          rdn = spec_RDN_Or_String;
          this.setFromRDN(rdn, granularity);
          break;
        default:
          spec = spec_RDN_Or_String;
          this.setFromSpec(spec);
      }
      this._inBoundsCheck();
      this._overUnderFlow();
    }

    ChartTime.prototype._inBoundsCheck = function() {
      var gs, lowest, pastHighest, segment, segments, temp, _i, _len, _results;
      if (this.beforePastFlag === '' || !(this.beforePastFlag != null)) {
        segments = ChartTime.granularitySpecs[this.granularity].segments;
        _results = [];
        for (_i = 0, _len = segments.length; _i < _len; _i++) {
          segment = segments[_i];
          gs = ChartTime.granularitySpecs[segment];
          temp = this[segment];
          lowest = gs.lowest;
          pastHighest = gs.pastHighest(this);
          if (temp < lowest || temp >= pastHighest) {
            if (temp === lowest - 1) {
              this[segment]++;
              _results.push(this.decrement(segment));
            } else if (temp === pastHighest) {
              this[segment]--;
              _results.push(this.increment(segment));
            } else {
              throw new Error("Tried to set " + segment + " to " + temp + ". It must be >= " + lowest + " and < " + pastHighest);
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    ChartTime.prototype.setFromSpec = function(spec) {
      var segment, segments, _i, _len, _results;
      utils.assert(spec.granularity != null, 'A granularity property must be part of the supplied spec.');
      this.granularity = spec.granularity;
      this.beforePastFlag = spec.beforePastFlag != null ? spec.beforePastFlag : '';
      segments = ChartTime.granularitySpecs[this.granularity].segments;
      _results = [];
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        if (spec[segment] != null) {
          _results.push(this[segment] = spec[segment]);
        } else {
          _results.push(this[segment] = ChartTime.granularitySpecs[segment].lowest);
        }
      }
      return _results;
    };

    ChartTime.prototype.setFromString = function(s, granularity) {
      /*
          Parses a string to set the segments/properties of this ChartTime. If a granularity is not provided, it will use the `masks` in 
          `granularitySpecs` to figure it out.
          
          If the granularity is specified but not all of the segments are provided, it will
          fill in the missing value with the `lowest` value from granularitySpecs.
          
          This parser does not work on all valid ISO-8601 forms. Ordinal dates are not supported at all and you must use the canonical
          form for your string. The Lumenize hierarchy tools rely upon the property that a single digit is used between segments.
      
          If the string has timezone indicator on the end (`...+05:00` or `...Z`), it will ignore it.
      */
      var g, gs, l, segment, segments, spec, stillParsing, sub, _i, _len, _ref2, _ref3, _results;
      if (s.slice(-3, -2) === ':' && (_ref2 = s.slice(-6, -5), __indexOf.call('+-', _ref2) >= 0)) {
        s = s.slice(0, -6);
      }
      if (s.slice(-1) === 'Z') s = s.slice(0, -1);
      if (s === 'PAST_LAST' || s === 'BEFORE_FIRST') {
        if (granularity != null) {
          this.granularity = granularity;
          this.beforePastFlag = s;
          return;
        } else {
          throw new Error('PAST_LAST/BEFORE_FIRST must have a granularity');
        }
      }
      if (!(granularity != null)) {
        _ref3 = ChartTime.granularitySpecs;
        for (g in _ref3) {
          spec = _ref3[g];
          if (spec.segmentStart + spec.segmentLength === s.length || spec.mask.indexOf('#') < 0) {
            if (spec.regex.test(s)) {
              granularity = g;
              break;
            }
          }
        }
        if (!(granularity != null)) {
          throw new Error("Error parsing string '" + s + "'. Couldn't identify granularity.");
        }
      } else {
        spec = ChartTime.granularitySpecs[granularity];
        if (spec.segmentStart + spec.segmentLength !== s.length || !spec.regex.test(s)) {
          throw new Error("Error parsing string '" + s + "'. Doesn't match mask for granularity " + granularity + ".");
        }
      }
      this.granularity = granularity;
      segments = ChartTime.granularitySpecs[this.granularity].segments;
      stillParsing = true;
      _results = [];
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        if (stillParsing) {
          gs = ChartTime.granularitySpecs[segment];
          l = gs.segmentLength;
          sub = ChartTime._getStringPart(s, segment);
          if (sub.length !== l) stillParsing = false;
        }
        if (stillParsing) {
          _results.push(this[segment] = Number(sub));
        } else {
          _results.push(this[segment] = ChartTime.granularitySpecs[segment].lowest);
        }
      }
      return _results;
    };

    ChartTime._getStringPart = function(s, segment) {
      var l, st, sub;
      spec = ChartTime.granularitySpecs[segment];
      l = spec.segmentLength;
      st = spec.segmentStart;
      sub = s.substr(st, l);
      return sub;
    };

    ChartTime.prototype.setFromRDN = function(rdn, granularity) {
      /*
          Sets the ChartTime object segments from the rata die number. Works for the granularities finer than day but 
          uses the `lowest` for those segments.
          
          It also works for custom timebox granularities. It will Error if your request is before the first possible
          value. This is because it only pays attention to the start of the timebox. However, if your target date is past the end 
          of your last custom granularity it will still return the highest possible value rather than Error. It doesn't know timeboxes. 
          It only knows RDN for release which will be the RDN of the start of the Release. So it essentially only pay attention to 
          the start of the timeboxes. It uses the start of the next Release as the pastEnd to bracket the rdn
          value that is passed in. Since there is no next value for the last one, it assumes the last one goes on forever.
      */
      var J, a, afterCT, afterRDN, b, beforeCT, beforeRDN, c, d, da, db, dc, dg, granularitySpec, j, m, n, segment, specForLowest, w, x, y, z, _i, _len, _ref2;
      spec = {
        granularity: granularity
      };
      switch (granularity) {
        case 'week':
        case 'week_day':
          w = Math.floor((rdn - 1) / 7);
          d = (rdn - 1) % 7;
          n = Math.floor(w / 20871);
          w = w % 20871;
          z = w + (w >= 10435 ? 1 : 0);
          c = Math.floor(z / 5218);
          w = z % 5218;
          x = w * 28 + [15, 23, 3, 11][c];
          y = Math.floor(x / 1461);
          w = x % 1461;
          spec['year'] = y + n * 400 + c * 100 + 1;
          spec['week'] = Math.floor(w / 28) + 1;
          spec['week_day'] = d + 1;
          return this.setFromSpec(spec);
        case 'year':
        case 'month':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
        case 'millisecond':
        case 'quarter':
          J = rdn + 1721425;
          j = J + 32044;
          g = Math.floor(j / 146097);
          dg = j % 146097;
          c = Math.floor((Math.floor(dg / 36524) + 1) * 3 / 4);
          dc = dg - c * 36524;
          b = Math.floor(dc / 1461);
          db = dc % 1461;
          a = Math.floor((Math.floor(db / 365) + 1) * 3 / 4);
          da = db - a * 365;
          y = g * 400 + c * 100 + b * 4 + a;
          m = Math.floor((da * 5 + 308) / 153) - 2;
          d = da - Math.floor((m + 4) * 153 / 5) + 122;
          spec['year'] = y - 4800 + Math.floor((m + 2) / 12);
          spec['month'] = (m + 2) % 12 + 1;
          spec['day'] = Math.floor(d) + 1;
          spec['quarter'] = Math.floor((spec.month - 1) / 3) + 1;
          return this.setFromSpec(spec);
        default:
          granularitySpec = ChartTime.granularitySpecs[granularity];
          specForLowest = {
            granularity: granularity
          };
          _ref2 = granularitySpec.segments;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            segment = _ref2[_i];
            specForLowest[segment] = ChartTime.granularitySpecs[segment].lowest;
          }
          beforeCT = new ChartTime(specForLowest);
          beforeRDN = beforeCT.rataDieNumber();
          afterCT = beforeCT.add(1);
          afterRDN = afterCT.rataDieNumber();
          if (rdn < beforeRDN) {
            this.beforePastFlag = 'BEFORE_FIRST';
            return;
          }
          while (true) {
            if (rdn < afterRDN && rdn >= beforeRDN) {
              this.setFromSpec(beforeCT);
              return;
            }
            beforeCT = afterCT;
            beforeRDN = afterRDN;
            afterCT = beforeCT.add(1);
            afterRDN = afterCT.rataDieNumber();
            if (afterCT.beforePastFlag === 'PAST_LAST') {
              if (rdn >= ChartTime.granularitySpecs[beforeCT.granularity].dayPastEnd.rataDieNumber()) {
                this.setFromSpec(afterCT);
                this.beforePastFlag === 'PAST_LAST';
                return;
              } else if (rdn >= beforeRDN) {
                this.setFromSpec(beforeCT);
                return;
              } else {
                throw new Error("RDN: " + rdn + " seems to be out of range for " + granularity);
              }
            }
          }
          throw new Error("Something went badly wrong setting custom granularity " + granularity + " for RDN: " + rdn);
      }
    };

    ChartTime.prototype.granularityAboveDay = function() {
      var segment, _i, _len, _ref2;
      _ref2 = ChartTime.granularitySpecs[this.granularity].segments;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        segment = _ref2[_i];
        if (segment.indexOf('day') >= 0) return false;
      }
      return true;
    };

    ChartTime.setTZPath = function(tzPath) {
      timezoneJS.timezone.zoneFileBasePath = tzPath;
      return timezoneJS.timezone.init();
    };

    ChartTime.prototype.getJSDate = function(tz) {
      var ct, newDate, offset, utcMilliseconds;
      utils.assert(tz != null, 'Must provide a timezone');
      utils.assert(timezoneJS.timezone.zoneFileBasePath != null, 'Call ChartTime.setTZPath("path/to/tz/files") before calling getJSDate.');
      ct = this.inGranularity('millisecond');
      console.log(ct);
      utcMilliseconds = Date.UTC(ct.year, ct.month, ct.day, ct.hour, ct.minute, ct.second, ct.millisecond);
      offset = timezoneJS.timezone.getTzInfo(new Date(utcMilliseconds), tz).tzOffset;
      utcMilliseconds += offset * 1000 * 60;
      newDate = new Date(utcMilliseconds);
      return newDate;
    };

    ChartTime.prototype.toString = function() {
      /*
          Uses granularity `mask` to generate the string representation.
      */
      var after, before, granularitySpec, l, s, segment, segments, start, _i, _len, _ref2;
      if ((_ref2 = this.beforePastFlag) === 'BEFORE_FIRST' || _ref2 === 'PAST_LAST') {
        s = "" + this.beforePastFlag;
      } else {
        s = ChartTime.granularitySpecs[this.granularity].mask;
        segments = ChartTime.granularitySpecs[this.granularity].segments;
        for (_i = 0, _len = segments.length; _i < _len; _i++) {
          segment = segments[_i];
          granularitySpec = ChartTime.granularitySpecs[segment];
          l = granularitySpec.segmentLength;
          start = granularitySpec.segmentStart;
          before = s.slice(0, start);
          after = s.slice(start + l);
          s = before + ChartTime._pad(this[segment], l) + after;
        }
      }
      return s;
    };

    ChartTime._pad = function(n, l) {
      var result;
      result = n.toString();
      while (result.length < l) {
        result = '0' + result;
      }
      return result;
    };

    ChartTime.DOW_N_TO_S_MAP = {
      0: 'Sunday',
      1: 'Monday',
      2: 'Tuesday',
      3: 'Wednesday',
      4: 'Thursday',
      5: 'Friday',
      6: 'Saturday',
      7: 'Sunday'
    };

    ChartTime.DOW_MONTH_TABLE = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4];

    ChartTime.prototype.dowNumber = function() {
      /*
          Returns the day of the week as a number. Monday = 1, Sunday = 7
      */
      var dayNumber, y, _ref2;
      if (this.granularity === 'week_day') return this.week_day;
      if ((_ref2 = this.granularity) === 'day' || _ref2 === 'hour' || _ref2 === 'minute' || _ref2 === 'second' || _ref2 === 'millisecond') {
        y = this.year;
        if (this.month < 3) y--;
        dayNumber = (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) + ChartTime.DOW_MONTH_TABLE[this.month - 1] + this.day) % 7;
        if (dayNumber === 0) {
          return 7;
        } else {
          return dayNumber;
        }
      } else {
        return this.inGranularity('day').dowNumber();
      }
    };

    ChartTime.prototype.dowString = function() {
      /*
          Returns the day of the week as a String.
      */      return ChartTime.DOW_N_TO_S_MAP[this.dowNumber()];
    };

    ChartTime.prototype.rataDieNumber = function() {
      /*
          Returns the number of days since 0001-01-01. 
          Works for granularities of hour, minute, second, millisecond but ignores the 
          segments of lower order than day.
      */
      var ew, monthDays, y, yearDays;
      if (this.beforePastFlag === 'BEFORE_FIRST') {
        return -1;
      } else if (this.beforePastFlag === 'PAST_LAST') {
        return utils.MAX_INT;
      } else if (ChartTime.granularitySpecs[this.granularity].rataDieNumber != null) {
        return ChartTime.granularitySpecs[this.granularity].rataDieNumber(this);
      } else {
        y = this.year - 1;
        yearDays = y * 365 + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400);
        ew = Math.floor((yearDays + 3) / 7);
        if (this.month != null) {
          monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334][this.month - 1];
          if (this.isLeapYear() && this.month >= 3) monthDays++;
        } else if (this.quarter != null) {
          monthDays = [0, 90, 181, 273][this.quarter - 1];
          if (this.isLeapYear() && this.quarter >= 2) monthDays++;
        } else {
          monthDays = 0;
        }
        switch (this.granularity) {
          case 'year':
            return yearDays + 1;
          case 'month':
          case 'quarter':
            return yearDays + monthDays + 1;
          case 'day':
          case 'hour':
          case 'minute':
          case 'second':
          case 'millisecond':
            return yearDays + monthDays + this.day;
          case 'week':
            return (ew + this.week - 1) * 7 + 1;
          case 'week_day':
            return (ew + this.week - 1) * 7 + this.week_day;
        }
      }
    };

    ChartTime.prototype.inGranularity = function(granularity) {
      /*
          Returns a new ChartTime object for the same date-time as this object but in the specified granularity.
          Fills in missing bits with `lowest` values.
      */
      var newChartTime, tempGranularity, _ref2;
      if ((_ref2 = this.granularity) === 'year' || _ref2 === 'month' || _ref2 === 'day' || _ref2 === 'hour' || _ref2 === 'minute' || _ref2 === 'second' || _ref2 === 'millisecond') {
        if (granularity === 'year' || granularity === 'month' || granularity === 'day' || granularity === 'hour' || granularity === 'minute' || granularity === 'second' || granularity === 'millisecond') {
          tempGranularity = this.granularity;
          this.granularity = granularity;
          newChartTime = new ChartTime(this);
          this.granularity = tempGranularity;
          return newChartTime;
        }
      }
      return new ChartTime(this.rataDieNumber(), granularity);
    };

    ChartTime.prototype.daysInMonth = function() {
      switch (this.month) {
        case 4:
        case 6:
        case 9:
        case 11:
          return 30;
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
        case 0:
          return 31;
        case 2:
          if (this.isLeapYear()) {
            return 29;
          } else {
            return 28;
          }
      }
    };

    ChartTime.prototype.isLeapYear = function() {
      if (this.year % 4 === 0) {
        if (this.year % 100 === 0) {
          if (this.year % 400 === 0) {
            return true;
          } else {
            return false;
          }
        } else {
          return true;
        }
      } else {
        return false;
      }
    };

    ChartTime.YEARS_WITH_53_WEEKS = [4, 9, 15, 20, 26, 32, 37, 43, 48, 54, 60, 65, 71, 76, 82, 88, 93, 99, 105, 111, 116, 122, 128, 133, 139, 144, 150, 156, 161, 167, 172, 178, 184, 189, 195, 201, 207, 212, 218, 224, 229, 235, 240, 246, 252, 257, 263, 268, 274, 280, 285, 291, 296, 303, 308, 314, 320, 325, 331, 336, 342, 348, 353, 359, 364, 370, 376, 381, 387, 392, 398];

    ChartTime.prototype.is53WeekYear = function() {
      var lookup;
      lookup = this.year % 400;
      return __indexOf.call(ChartTime.YEARS_WITH_53_WEEKS, lookup) >= 0;
    };

    ChartTime.prototype.$eq = function(other) {
      /*
          Returns true if this equals other. Throws an error if the granularities don't match.
      
              d3 = new ChartTime({granularity: 'day', year: 2011, month: 12, day: 31})
              d4 = new ChartTime('2012-01-01').add(-1)
              console.log(d3.$eq(d4))
              # true
      */
      var segment, segments, _i, _len;
      utils.assert(this.granularity === other.granularity, 'Granularities must match on equality/inequality test.');
      if (this.beforePastFlag === 'PAST_LAST' && other.beforePastFlag === 'PAST_LAST') {
        return true;
      }
      if (this.beforePastFlag === 'BEFORE_FIRST' && other.beforePastFlag === 'BEFORE_FIRST') {
        return true;
      }
      if (this.beforePastFlag === 'PAST_LAST' && other.beforePastFlag !== 'PAST_LAST') {
        return false;
      }
      if (this.beforePastFlag === 'BEFORE_FIRST' && other.beforePastFlag !== 'BEFORE_FIRST') {
        return false;
      }
      if (other.beforePastFlag === 'PAST_LAST' && this.beforePastFlag !== 'PAST_LAST') {
        return false;
      }
      if (other.beforePastFlag === 'BEFORE_FIRST' && this.beforePastFlag !== 'BEFORE_FIRST') {
        return false;
      }
      segments = ChartTime.granularitySpecs[this.granularity].segments;
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        if (this[segment] !== other[segment]) return false;
      }
      return true;
    };

    ChartTime.prototype.$gt = function(other) {
      /*
          Returns true if this is greater than other. Throws an error if the granularities don't match
      
              d1 = new ChartTime({granularity: 'day', year: 2011, month: 2, day: 28})
              d2 = new ChartTime({granularity: 'day', year: 2011, month: 3, day: 1})
              console.log(d1.$gt(d2))
              # false
              console.log(d2.$gt(d1))
              # true
      */
      var segment, segments, _i, _len;
      utils.assert(this.granularity === other.granularity, 'Granularities must match on equality/inequality test.');
      if (this.beforePastFlag === 'PAST_LAST' && other.beforePastFlag === 'PAST_LAST') {
        return false;
      }
      if (this.beforePastFlag === 'BEFORE_FIRST' && other.beforePastFlag === 'BEFORE_FIRST') {
        return false;
      }
      if (this.beforePastFlag === 'PAST_LAST' && other.beforePastFlag !== 'PAST_LAST') {
        return true;
      }
      if (this.beforePastFlag === 'BEFORE_FIRST' && other.beforePastFlag !== 'BEFORE_FIRST') {
        return false;
      }
      if (other.beforePastFlag === 'PAST_LAST' && this.beforePastFlag !== 'PAST_LAST') {
        return false;
      }
      if (other.beforePastFlag === 'BEFORE_FIRST' && this.beforePastFlag !== 'BEFORE_FIRST') {
        return true;
      }
      segments = ChartTime.granularitySpecs[this.granularity].segments;
      for (_i = 0, _len = segments.length; _i < _len; _i++) {
        segment = segments[_i];
        if (this[segment] > other[segment]) return true;
        if (this[segment] < other[segment]) return false;
      }
      return false;
    };

    ChartTime.prototype.$gte = function(other) {
      if (this.$eq(other)) return true;
      return this.$gt(other);
    };

    ChartTime.prototype.$lt = function(other) {
      return other.$gt(this);
    };

    ChartTime.prototype.$lte = function(other) {
      return other.$gte(this);
    };

    ChartTime.prototype._overUnderFlow = function() {
      var granularitySpec, highestLevel, highestLevelSpec, lowest, pastHighest, value, _ref2;
      if ((_ref2 = this.beforePastFlag) === 'BEFORE_FIRST' || _ref2 === 'PAST_LAST') {
        return true;
      } else {
        granularitySpec = ChartTime.granularitySpecs[this.granularity];
        highestLevel = granularitySpec.segments[0];
        highestLevelSpec = ChartTime.granularitySpecs[highestLevel];
        value = this[highestLevel];
        pastHighest = highestLevelSpec.pastHighest(this);
        lowest = highestLevelSpec.lowest;
        if (value >= pastHighest) {
          this.beforePastFlag = 'PAST_LAST';
          return true;
        } else if (value < lowest) {
          this.beforePastFlag = 'BEFORE_FIRST';
          return true;
        } else {
          return false;
        }
      }
    };

    ChartTime.prototype.decrement = function(granularity) {
      /*
          Decrements by 1.
      */
      var granularitySpec, gs, i, lastDayInMonthFlag, segment, segments, _i, _len, _results;
      if (this.beforePastFlag === 'PAST_LAST') {
        this.beforePastFlag = '';
        granularitySpec = ChartTime.granularitySpecs[this.granularity];
        segments = granularitySpec.segments;
        _results = [];
        for (_i = 0, _len = segments.length; _i < _len; _i++) {
          segment = segments[_i];
          gs = ChartTime.granularitySpecs[segment];
          _results.push(this[segment] = gs.pastHighest(this) - 1);
        }
        return _results;
      } else {
        lastDayInMonthFlag = this.day === this.daysInMonth();
        if (granularity == null) granularity = this.granularity;
        granularitySpec = ChartTime.granularitySpecs[granularity];
        segments = granularitySpec.segments;
        this[granularity]--;
        if (granularity === 'year') {
          if (this.day > this.daysInMonth()) return this.day = this.daysInMonth();
        } else {
          i = segments.length - 1;
          segment = segments[i];
          granularitySpec = ChartTime.granularitySpecs[segment];
          while ((i > 0) && (this[segment] < granularitySpec.lowest)) {
            this[segments[i - 1]]--;
            this[segment] = granularitySpec.pastHighest(this) - 1;
            i--;
            segment = segments[i];
            granularitySpec = ChartTime.granularitySpecs[segment];
          }
          if (granularity === 'month' && (this.granularity !== 'month')) {
            if (lastDayInMonthFlag || (this.day > this.daysInMonth())) {
              this.day = this.daysInMonth();
            }
          }
          return this._overUnderFlow();
        }
      }
    };

    ChartTime.prototype.increment = function(granularity) {
      /*
          Increments by 1.
      */
      var granularitySpec, gs, i, lastDayInMonthFlag, segment, segments, _i, _len, _results;
      if (this.beforePastFlag === 'BEFORE_FIRST') {
        this.beforePastFlag = '';
        granularitySpec = ChartTime.granularitySpecs[this.granularity];
        segments = granularitySpec.segments;
        _results = [];
        for (_i = 0, _len = segments.length; _i < _len; _i++) {
          segment = segments[_i];
          gs = ChartTime.granularitySpecs[segment];
          _results.push(this[segment] = gs.lowest);
        }
        return _results;
      } else {
        lastDayInMonthFlag = this.day === this.daysInMonth();
        if (granularity == null) granularity = this.granularity;
        granularitySpec = ChartTime.granularitySpecs[granularity];
        segments = granularitySpec.segments;
        this[granularity]++;
        if (granularity === 'year') {
          if (this.day > this.daysInMonth()) return this.day = this.daysInMonth();
        } else {
          i = segments.length - 1;
          segment = segments[i];
          granularitySpec = ChartTime.granularitySpecs[segment];
          while ((i > 0) && (this[segment] >= granularitySpec.pastHighest(this))) {
            this[segment] = granularitySpec.lowest;
            this[segments[i - 1]]++;
            i--;
            segment = segments[i];
            granularitySpec = ChartTime.granularitySpecs[segment];
          }
          if ((granularity === 'month') && (this.granularity !== 'month')) {
            if (lastDayInMonthFlag || (this.day > this.daysInMonth())) {
              this.day = this.daysInMonth();
            }
          }
          return this._overUnderFlow();
        }
      }
    };

    ChartTime.prototype.addInPlace = function(qty, granularity) {
      /*
          Adds qty to the ChartTime object. It uses increment and decrement so it's not going to be efficient for large values
          of qty, but it should be fine for charts where we'll increment/decrement small values of qty.
      
          qty can be negative for subtraction.
      */      if (granularity == null) granularity = this.granularity;
      if (qty === 0) return;
      if (qty === 1) {
        return this.increment(granularity);
      } else if (qty > 1) {
        this.increment(granularity);
        return this.addInPlace(qty - 1, granularity);
      } else if (qty === -1) {
        return this.decrement(granularity);
      } else {
        this.decrement(granularity);
        return this.addInPlace(qty + 1, granularity);
      }
    };

    ChartTime.prototype.add = function(qty, granularity) {
      /*
          Adds (or subtracts) quantity (negative quantity) and returns a new ChartTime.
      */
      var newChartTime;
      newChartTime = new ChartTime(this);
      newChartTime.addInPlace(qty, granularity);
      return newChartTime;
    };

    return ChartTime;

  })();

  ChartTimeIterator = (function() {

    /*
      # ChartTimeIterator #
      
      Iterate through days, months, years, etc. skipping weekends and holidays that you 
      specify. It will also iterate over hours, minutes, seconds, etc. and skip times that are not
      between the specified work hours.
      
      Example:
      
          ChartTime = require('charttime').ChartTime
          ChartTimeIterator = require('charttimeiterator').ChartTimeIterator
      
          cti = new ChartTimeIterator({
            start:new ChartTime({granularity: 'day', year: 2009, month:1, day: 1}),
            pastEnd:new ChartTime({granularity: 'day', year: 2009, month:1, day: 8}),
            workDays: 'Monday, Tuesday, Wednesday, Thursday, Friday',
            holidays: [
              {month: 1, day: 1},  # New Years day was a Thursday in 2009
              {year: 2009, month: 1, day: 2}  # Also got Friday off in 2009
            ]
          })
      
          while (cti.hasNext())
            console.log(cti.next().toString())
      
          # 2009-01-05
          # 2009-01-06
          # 2009-01-07
    */

    var StopIteration;

    StopIteration = typeof StopIteration === 'undefined' ? utils.StopIteration : StopIteration;

    function ChartTimeIterator(spec) {
      /*
          spec can have the following properties:
      
          * **start** is a ChartTime object. The first day that next() returns
          * **pastEnd** is a ChartTime object. Must match granularity. hasNext() returns false when current is here or later.
          * **skip** is an optional num. Defaults to 1. Use -1 to march backwards from pastEnd - 1
          * **limit** you can specify limit plus one of start/pastEnd and only get back this many.
          * **workDays** list of days of the week that you work on. Either ['Monday', 'Tuesday', ...] or "Monday,Tuesday,..."
             Defaults to ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].
          * **holidays** is an optional Array like: [{month: 12, day: 25}, {year: 2011, month: 11, day: 24}]. Notice how
             you can leave off the year if the holiday falls on the same day every year.
          * **startWorkTime** is an optional object in the form {hour: 8, minute: 15}. Must include minute even when 0.
             If startWorkTime is later than pastEndWorkTime, then it assumes that you work the night shift and your work
             hours span midnight.
          * **pastEndWorkTime** is an optional object in the form {hour: 17, minute: 0}. Must include minute even when 0.
             The use of startWorkTime and pastEndWorkTime only make sense when the granularity is "hour" or finer.
             Note: If the business closes at 5:00pm, you'll want to leave pastEndWorkTime to 17:00, rather
             than 17:01. Think about it, you'll be open 4:59:59.999pm, but you'll be closed at 5:00pm. This also makes all of
             the math work. 9am to 5pm means 17 - 9 = an 8 hour work day.
      */
      var s, _ref;
      if (spec.skip != null) {
        this.skip = spec.skip;
      } else if ((spec.pastEnd != null) && ((_ref = spec.start) != null ? _ref.$gt(spec.pastEnd) : void 0)) {
        this.skip = -1;
      } else {
        this.skip = 1;
      }
      utils.assert(((spec.start != null) && (spec.pastEnd != null)) || ((spec.start != null) && (spec.limit != null) && this.skip > 0) || ((spec.pastEnd != null) && (spec.limit != null) && this.skip < 0), 'Must provide two out of "start", "pastEnd", or "limit" and the sign of skip must match.');
      this.granularity = spec.start != null ? spec.start.granularity : spec.pastEnd.granularity;
      this.start = spec.start != null ? spec.start : new ChartTime('BEFORE_FIRST', this.granularity);
      this.pastEnd = spec.pastEnd != null ? spec.pastEnd : new ChartTime('PAST_LAST', this.granularity);
      this.limit = spec.limit != null ? spec.limit : utils.MAX_INT;
      this.workDays = spec.workDays != null ? spec.workDays : ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
      if (utils.type(this.workDays) === 'string') {
        this.workDays = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = this.workDays.split(',');
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            s = _ref2[_i];
            _results.push(utils.trim(s));
          }
          return _results;
        }).call(this);
      }
      this.holidays = spec.holidays != null ? spec.holidays : [];
      this.startWorkTime = spec.startWorkTime != null ? spec.startWorkTime : void 0;
      this.startWorkMinutes = this.startWorkTime != null ? this.startWorkTime.hour * 60 + this.startWorkTime.minute : 0;
      this.pastEndWorkTime = spec.pastEndWorkTime != null ? spec.pastEndWorkTime : void 0;
      this.pastEndMinutes = this.pastEndWorkTime != null ? this.pastEndWorkTime.hour * 60 + this.pastEndWorkTime.minute : 24 * 60;
      this.startOver();
    }

    ChartTimeIterator.prototype.startOver = function() {
      /*
          Will go back to the where the iterator started.
      */      if (this.skip > 0) {
        this.current = new ChartTime(this.start);
      } else {
        this.current = new ChartTime(this.pastEnd);
        this.current.decrement();
      }
      this.count = 0;
      return this._proceedToNextValid();
    };

    ChartTimeIterator.prototype.hasNext = function() {
      return this.current.$lt(this.pastEnd) && this.current.$gte(this.start) && (this.count < this.limit);
    };

    ChartTimeIterator.prototype._shouldBeExcluded = function() {
      var currentInDay, currentMinutes, holiday, _i, _len, _ref, _ref2, _ref3;
      if (this.current.granularityAboveDay()) return false;
      currentInDay = this.current.inGranularity('day');
      if (!(_ref = this.current.dowString(), __indexOf.call(this.workDays, _ref) >= 0)) {
        return true;
      }
      _ref2 = this.holidays;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        holiday = _ref2[_i];
        if (utils.match(holiday, currentInDay)) return true;
      }
      if ((_ref3 = this.granularity) === 'hour' || _ref3 === 'minute' || _ref3 === ' second' || _ref3 === 'millisecond') {
        currentMinutes = this.current.hour * 60;
        if (this.current.minute != null) currentMinutes += this.current.minute;
        if (this.startWorkMinutes <= this.pastEndMinutes) {
          if ((currentMinutes < this.startWorkMinutes) || (currentMinutes >= this.pastEndMinutes)) {
            return true;
          }
        } else {
          if ((this.startWorkMinutes >= currentMinutes && currentMinutes > this.pastEndMinutes)) {
            return true;
          }
        }
      }
      return false;
    };

    ChartTimeIterator.prototype._proceedToNextValid = function() {
      var _results;
      _results = [];
      while (this.hasNext() && this._shouldBeExcluded()) {
        if (this.skip > 0) {
          _results.push(this.current.increment());
        } else {
          _results.push(this.current.decrement());
        }
      }
      return _results;
    };

    ChartTimeIterator.prototype.next = function() {
      var currentCopy, i, _ref;
      if (!this.hasNext()) throw new StopIteration('Cannot call next() past end.');
      currentCopy = new ChartTime(this.current);
      this.count++;
      for (i = _ref = Math.abs(this.skip); _ref <= 1 ? i <= 1 : i >= 1; _ref <= 1 ? i++ : i--) {
        if (this.skip > 0) {
          this.current.increment();
        } else {
          this.current.decrement();
        }
        this._proceedToNextValid();
      }
      return currentCopy;
    };

    ChartTimeIterator.prototype.getAll = function() {
      /*
          Returns all values as an array.
      */
      var temp;
      this.startOver();
      temp = [];
      while (this.hasNext()) {
        temp.push(this.next());
      }
      return temp;
    };

    return ChartTimeIterator;

  })();

  exports.ChartTimeIterator = ChartTimeIterator;

  exports.ChartTime = ChartTime;

}).call(this);

});

require.define("/utils.coffee", function (require, module, exports, __dirname, __filename) {
    (function() {

  /*
  # ChartTime utils #
  Copyright (c) Lawrence S. Maccherone, Jr., 2012
  */

  var AssertException, ErrorBase, StopIteration, assert, isArray, match, trim, type;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  exports.MAX_INT = 2147483647;

  exports.MIN_INT = -2147483648;

  ErrorBase = (function() {

    __extends(ErrorBase, Error);

    function ErrorBase(message) {
      this.message = message != null ? message : 'Unknown error.';
      if (Error.captureStackTrace != null) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
    }

    ErrorBase.prototype.toString = function() {
      return "" + this.name + ": " + this.message;
    };

    return ErrorBase;

  })();

  AssertException = (function() {

    __extends(AssertException, ErrorBase);

    function AssertException() {
      AssertException.__super__.constructor.apply(this, arguments);
    }

    return AssertException;

  })();

  StopIteration = (function() {

    __extends(StopIteration, ErrorBase);

    function StopIteration() {
      StopIteration.__super__.constructor.apply(this, arguments);
    }

    return StopIteration;

  })();

  assert = function(exp, message) {
    if (!exp) throw new exports.AssertException(message);
  };

  match = function(obj1, obj2) {
    var key, value;
    for (key in obj1) {
      if (!__hasProp.call(obj1, key)) continue;
      value = obj1[key];
      if (value !== obj2[key]) return false;
    }
    return true;
  };

  trim = function(val) {
    if (String.prototype.trim != null) {
      return val.trim();
    } else {
      return val.replace(/^\s+|\s+$/g, "");
    }
  };

  isArray = function(a) {
    return Object.prototype.toString.apply(a) === '[object Array]';
  };

  type = (function() {
    var classToType, name, _i, _len, _ref;
    classToType = {};
    _ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var strType;
      strType = Object.prototype.toString.call(obj);
      return classToType[strType] || "object";
    };
  })();

  exports.AssertException = AssertException;

  exports.StopIteration = StopIteration;

  exports.assert = assert;

  exports.match = match;

  exports.trim = trim;

  exports.isArray = isArray;

  exports.type = type;

}).call(this);

});

require.define("/node_modules/timezone-js.js", function (require, module, exports, __dirname, __filename) {
    /*
 * Copyright 2010 Matthew Eernisse (mde@fleegix.org)
 * and Open Source Applications Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Credits: Ideas included from incomplete JS implementation of Olson
 * parser, "XMLDAte" by Philippe Goetz (philippe.goetz@wanadoo.fr)
 *
 * Contributions:
 * Jan Niehusmann
 * Ricky Romero
 * Preston Hunt (prestonhunt@gmail.com),
 * Dov. B Katz (dov.katz@morganstanley.com),
 * Peter Bergström (pbergstr@mac.com)
*/
if (typeof fleegix == 'undefined') { var fleegix = {}; }
if (typeof exports.timezoneJS == 'undefined') { exports.timezoneJS = {}; }

fs = require('fs');

exports.timezoneJS.timezone = new function() {
  var _this = this;
  var monthMap = { 'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3,'may': 4, 'jun': 5,
    'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11 };
  var dayMap = {'sun': 0,'mon' :1, 'tue': 2, 'wed': 3, 'thu': 4, 'fri': 5, 'sat': 6 };
  var regionMap = {'EST':'northamerica','MST':'northamerica','HST':'northamerica','EST5EDT':'northamerica','CST6CDT':'northamerica','MST7MDT':'northamerica','PST8PDT':'northamerica','America':'northamerica','Pacific':'australasia','Atlantic':'europe','Africa':'africa','Indian':'africa','Antarctica':'antarctica','Asia':'asia','Australia':'australasia','Europe':'europe','WET':'europe','CET':'europe','MET':'europe','EET':'europe'};
  var regionExceptions = {'Pacific/Honolulu':'northamerica','Atlantic/Bermuda':'northamerica','Atlantic/Cape_Verde':'africa','Atlantic/St_Helena':'africa','Indian/Kerguelen':'antarctica','Indian/Chagos':'asia','Indian/Maldives':'asia','Indian/Christmas':'australasia','Indian/Cocos':'australasia','America/Danmarkshavn':'europe','America/Scoresbysund':'europe','America/Godthab':'europe','America/Thule':'europe','Asia/Yekaterinburg':'europe','Asia/Omsk':'europe','Asia/Novosibirsk':'europe','Asia/Krasnoyarsk':'europe','Asia/Irkutsk':'europe','Asia/Yakutsk':'europe','Asia/Vladivostok':'europe','Asia/Sakhalin':'europe','Asia/Magadan':'europe','Asia/Kamchatka':'europe','Asia/Anadyr':'europe','Africa/Ceuta':'europe','America/Argentina/Buenos_Aires':'southamerica','America/Argentina/Cordoba':'southamerica','America/Argentina/Tucuman':'southamerica','America/Argentina/La_Rioja':'southamerica','America/Argentina/San_Juan':'southamerica','America/Argentina/Jujuy':'southamerica','America/Argentina/Catamarca':'southamerica','America/Argentina/Mendoza':'southamerica','America/Argentina/Rio_Gallegos':'southamerica','America/Argentina/Ushuaia':'southamerica','America/Aruba':'southamerica','America/La_Paz':'southamerica','America/Noronha':'southamerica','America/Belem':'southamerica','America/Fortaleza':'southamerica','America/Recife':'southamerica','America/Araguaina':'southamerica','America/Maceio':'southamerica','America/Bahia':'southamerica','America/Sao_Paulo':'southamerica','America/Campo_Grande':'southamerica','America/Cuiaba':'southamerica','America/Porto_Velho':'southamerica','America/Boa_Vista':'southamerica','America/Manaus':'southamerica','America/Eirunepe':'southamerica','America/Rio_Branco':'southamerica','America/Santiago':'southamerica','Pacific/Easter':'southamerica','America/Bogota':'southamerica','America/Curacao':'southamerica','America/Guayaquil':'southamerica','Pacific/Galapagos':'southamerica','Atlantic/Stanley':'southamerica','America/Cayenne':'southamerica','America/Guyana':'southamerica','America/Asuncion':'southamerica','America/Lima':'southamerica','Atlantic/South_Georgia':'southamerica','America/Paramaribo':'southamerica','America/Port_of_Spain':'southamerica','America/Montevideo':'southamerica','America/Caracas':'southamerica'};

  function invalidTZError(t) {
    throw new Error('Timezone "' + t + '" is either incorrect, or not loaded in the timezone registry.');
  }
  function builtInLoadZoneFile(fileName, opts) {
    if (typeof fleegix.xhr == 'undefined') {
      throw new Error('Please use the Fleegix.js XHR module, or define your own transport mechanism for downloading zone files.');
    }
    var url = _this.zoneFileBasePath + '/' + fileName;
    if (!opts.async) {
      var ret = fleegix.xhr.doReq({
        url: url,
        async: false
      });
      return _this.parseZones(ret);
    }
    else {
      return fleegix.xhr.send({
        url: url,
        method: 'get',
        handleSuccess: function (str) {
          if (_this.parseZones(str)) {
            if (typeof opts.callback == 'function') {
              opts.callback();
            }
          }
          return true;
        },
        handleErr: function () {
          throw new Error('Error retrieving "' + url + '" zoneinfo file.');
        }
      });
    }
  }
  
  
  function myLoadZoneFile(fileName, opts) {
    var url = _this.zoneFileBasePath + '/' + fileName; // !TODO: convert to nodeJS path
    if (fs.readFileSync) {
      process.chdir(__dirname);
      var ret = fs.readFileSync(url, 'utf8');
      return _this.parseZones(ret);
    }
    if (typeof XMLHttpRequest == 'undefined') {
      throw new Error('No XMLHttpRequest.');
    } else {
      xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      var ret = xhr.responseText;
      return _this.parseZones(ret);
    }
  }
  
  
  function getRegionForTimezone(tz) {
    var exc = regionExceptions[tz];
    var ret;
    if (exc) {
      return exc;
    }
    else {
      reg = tz.split('/')[0];
      ret = regionMap[reg];
      // If there's nothing listed in the main regions for
      // this TZ, check the 'backward' links
      if (!ret) {
        var link = _this.zones[tz];
        if (typeof link == 'string') {
          return getRegionForTimezone(link);
        }
        else {
          // Backward-compat file hasn't loaded yet, try looking in there
          if (!_this.loadedZones.backward) {
            // This is for obvious legacy zones (e.g., Iceland) that
            // don't even have a prefix like "America/" that look like
            // normal zones
            var parsed = _this.loadZoneFile('backward', true);
            return getRegionForTimezone(tz);
          }
          else {
            invalidTZError(tz);
          }
        }
      }
      return ret;
    }
  }
  function parseTimeString(str) {
    var pat = /(\d+)(?::0*(\d*))?(?::0*(\d*))?([wsugz])?$/;
    var hms = str.match(pat);
    hms[1] = parseInt(hms[1], 10);
    hms[2] = hms[2] ? parseInt(hms[2], 10) : 0;
    hms[3] = hms[3] ? parseInt(hms[3], 10) : 0;
    return hms;
  }
  function getZone(dt, tz) {
    var t = tz;
    var zoneList = _this.zones[t];
    // Follow links to get to an acutal zone
    while (typeof zoneList == "string") {
      t = zoneList;
      zoneList = _this.zones[t];
    }
    if (!zoneList) {
      // Backward-compat file hasn't loaded yet, try looking in there
      if (!_this.loadedZones.backward) {
        // This is for backward entries like "America/Fort_Wayne" that
        // getRegionForTimezone *thinks* it has a region file and zone
        // for (e.g., America => 'northamerica'), but in reality it's a
        // legacy zone we need the backward file for
        var parsed = _this.loadZoneFile('backward', true);
        return getZone(dt, tz);
      }
      invalidTZError(t);
    }
    for(var i = 0; i < zoneList.length; i++) {
      var z = zoneList[i];
      if (!z[3]) { break; }
      var yea = parseInt(z[3], 10);
      var mon = 11;
      var dat = 31;
      if (z[4]) {
        mon = monthMap[z[4].substr(0, 3).toLowerCase()];
        dat = parseInt(z[5], 10);
      }
      var t = z[6] ? z[6] : '23:59:59';
      t = parseTimeString(t);
      var d = Date.UTC(yea, mon, dat, t[1], t[2], t[3]);
      if (dt.getTime() < d) { break; }
    }
    if (i == zoneList.length) { throw new Error('No Zone found for "' + timezone + '" on ' + dt); }
    return zoneList[i];

  }
  function getBasicOffset(z) {
    var off = parseTimeString(z[0]);
    var adj = z[0].indexOf('-') == 0 ? -1 : 1
    off = adj * (((off[1] * 60 + off[2]) *60 + off[3]) * 1000);
    return -off/60/1000;
  }

  // if isUTC is true, date is given in UTC, otherwise it's given
  // in local time (ie. date.getUTC*() returns local time components)
  function getRule( date, zone, isUTC ) {
    var ruleset = zone[1];
    var basicOffset = getBasicOffset( zone );

    // Convert a date to UTC. Depending on the 'type' parameter, the date
    // parameter may be:
    // 'u', 'g', 'z': already UTC (no adjustment)
    // 's': standard time (adjust for time zone offset but not for DST)
    // 'w': wall clock time (adjust for both time zone and DST offset)
    //
    // DST adjustment is done using the rule given as third argument
    var convertDateToUTC = function( date, type, rule ) {
      var offset = 0;

      if(type == 'u' || type == 'g' || type == 'z') { // UTC
          offset = 0;
      } else if(type == 's') { // Standard Time
          offset = basicOffset;
      } else if(type == 'w' || !type ) { // Wall Clock Time
          offset = getAdjustedOffset(basicOffset,rule);
      } else {
          throw("unknown type "+type);
      }
      offset *= 60*1000; // to millis

      return new Date( date.getTime() + offset );
    }

    // Step 1:  Find applicable rules for this year.
    // Step 2:  Sort the rules by effective date.
    // Step 3:  Check requested date to see if a rule has yet taken effect this year.  If not,
    // Step 4:  Get the rules for the previous year.  If there isn't an applicable rule for last year, then
    //      there probably is no current time offset since they seem to explicitly turn off the offset
    //      when someone stops observing DST.
    //      FIXME if this is not the case and we'll walk all the way back (ugh).
    // Step 5:  Sort the rules by effective date.
    // Step 6:  Apply the most recent rule before the current time.

    var convertRuleToExactDateAndTime = function( yearAndRule, prevRule )
    {
      var year = yearAndRule[0];
      var rule = yearAndRule[1];

      // Assume that the rule applies to the year of the given date.
      var months = {
        "Jan": 0, "Feb": 1, "Mar": 2, "Apr": 3, "May": 4, "Jun": 5,
        "Jul": 6, "Aug": 7, "Sep": 8, "Oct": 9, "Nov": 10, "Dec": 11
      };

      var days = {
        "sun": 0, "mon": 1, "tue": 2, "wed": 3, "thu": 4, "fri": 5, "sat": 6
      }

      var hms = parseTimeString( rule[ 5 ] );
      var effectiveDate;

      if ( !isNaN( rule[ 4 ] ) ) // If we have a specific date, use that!
      {
        effectiveDate = new Date( Date.UTC( year, months[ rule[ 3 ] ], rule[ 4 ], hms[ 1 ], hms[ 2 ], hms[ 3 ], 0 ) );
      }
      else // Let's hunt for the date.
      {
        var targetDay,
          operator;

        if ( rule[ 4 ].substr( 0, 4 ) === "last" ) // Example: lastThu
        {
          // Start at the last day of the month and work backward.
          effectiveDate = new Date( Date.UTC( year, months[ rule[ 3 ] ] + 1, 1, hms[ 1 ] - 24, hms[ 2 ], hms[ 3 ], 0 ) );
          targetDay = days[ rule[ 4 ].substr( 4, 3 ).toLowerCase( ) ];
          operator = "<=";
        }
        else // Example: Sun>=15
        {
          // Start at the specified date.
          effectiveDate = new Date( Date.UTC( year, months[ rule[ 3 ] ], rule[ 4 ].substr( 5 ), hms[ 1 ], hms[ 2 ], hms[ 3 ], 0 ) );
          targetDay = days[ rule[ 4 ].substr( 0, 3 ).toLowerCase( ) ];
          operator = rule[ 4 ].substr( 3, 2 );
        }

        var ourDay = effectiveDate.getUTCDay( );

        if ( operator === ">=" ) // Go forwards.
        {
          effectiveDate.setUTCDate( effectiveDate.getUTCDate( ) + ( targetDay - ourDay + ( ( targetDay < ourDay ) ? 7 : 0 ) ) );
        }
        else // Go backwards.  Looking for the last of a certain day, or operator is "<=" (less likely).
        {
          effectiveDate.setUTCDate( effectiveDate.getUTCDate( ) + ( targetDay - ourDay - ( ( targetDay > ourDay ) ? 7 : 0 ) ) );
        }
      }

      // if previous rule is given, correct for the fact that the starting time of the current
      // rule may be specified in local time
      if(prevRule) {
        effectiveDate = convertDateToUTC(effectiveDate, hms[4], prevRule);
      }

      return effectiveDate;
    }

    var findApplicableRules = function( year, ruleset )
    {
      var applicableRules = [];

      for ( var i in ruleset )
      {
        if ( Number( ruleset[ i ][ 0 ] ) <= year ) // Exclude future rules.
        {
          if (
            Number( ruleset[ i ][ 1 ] ) >= year                                            // Date is in a set range.
            || ( Number( ruleset[ i ][ 0 ] ) === year && ruleset[ i ][ 1 ] === "only" )    // Date is in an "only" year.
            || ruleset[ i ][ 1 ] === "max"                                                 // We're in a range from the start year to infinity.
          )
          {
            // It's completely okay to have any number of matches here.
            // Normally we should only see two, but that doesn't preclude other numbers of matches.
            // These matches are applicable to this year.
            applicableRules.push( [year, ruleset[ i ]] );
          }
        }
      }

      return applicableRules;
    }

    var compareDates = function( a, b, prev )
    {
      if ( a.constructor !== Date ) {
        a = convertRuleToExactDateAndTime( a, prev );
      } else if(prev) {
        a = convertDateToUTC(a, isUTC?'u':'w', prev);
      }
      if ( b.constructor !== Date ) {
        b = convertRuleToExactDateAndTime( b, prev );
      } else if(prev) {
        b = convertDateToUTC(b, isUTC?'u':'w', prev);
      }

      a = Number( a );
      b = Number( b );

      return a - b;
    }

    var year = date.getUTCFullYear( );
    var applicableRules;

    applicableRules = findApplicableRules( year, _this.rules[ ruleset ] );
    applicableRules.push( date );
    // While sorting, the time zone in which the rule starting time is specified
    // is ignored. This is ok as long as the timespan between two DST changes is
    // larger than the DST offset, which is probably always true.
    // As the given date may indeed be close to a DST change, it may get sorted
    // to a wrong position (off by one), which is corrected below.
    applicableRules.sort( compareDates );

    if ( applicableRules.indexOf( date ) < 2 ) { // If there are not enough past DST rules...
      applicableRules = applicableRules.concat(findApplicableRules( year-1, _this.rules[ ruleset ] ));
      applicableRules.sort( compareDates );
    }

    var pinpoint = applicableRules.indexOf( date );
    if ( pinpoint > 1 && compareDates( date, applicableRules[pinpoint-1], applicableRules[pinpoint-2][1] ) < 0 ) {
      // the previous rule does not really apply, take the one before that
      return applicableRules[ pinpoint - 2 ][1];
    } else if ( pinpoint > 0 && pinpoint < applicableRules.length - 1 && compareDates( date, applicableRules[pinpoint+1], applicableRules[pinpoint-1][1] ) > 0) {
      // the next rule does already apply, take that one
      return applicableRules[ pinpoint + 1 ][1];
    } else if ( pinpoint === 0 ) {
      // no applicable rule found in this and in previous year
      return null;
    } else {
      return applicableRules[ pinpoint - 1 ][1];
    }
  }
  function getAdjustedOffset(off, rule) {
    var save = rule[6];
    var t = parseTimeString(save);
    var adj = save.indexOf('-') == 0 ? -1 : 1;
    var ret = (adj*(((t[1] *60 + t[2]) * 60 + t[3]) * 1000));
    ret = ret/60/1000;
    ret -= off
    ret = -Math.ceil(ret);
    return ret;
  }
  function getAbbreviation(zone, rule) {
    var res;
    var base = zone[2];
    if (base.indexOf('%s') > -1) {
      var repl;
      if (rule) {
        repl = rule[7]=='-'?'':rule[7];
      }
      // FIXME: Right now just falling back to Standard --
      // apparently ought to use the last valid rule,
      // although in practice that always ought to be Standard
      else {
        repl = 'S';
      }
      res = base.replace('%s', repl);
    }
    else if (base.indexOf('/') > -1) {
      // chose one of two alternative strings
      var t = parseTimeString(rule[6]);
      var isDst = (t[1])||(t[2])||(t[3]);
      res = base.split("/",2)[isDst?1:0];
    } else {
      res = base;
    }
    return res;
  }

  this.zoneFileBasePath;
  this.zoneFiles = ['africa', 'antarctica', 'asia',
    'australasia', 'backward', 'etcetera', 'europe',
    'northamerica', 'pacificnew', 'southamerica'];
  this.loadingSchemes = {
    PRELOAD_ALL: 'preloadAll',
    LAZY_LOAD: 'lazyLoad',
    MANUAL_LOAD: 'manualLoad'
  }
  this.loadingScheme = this.loadingSchemes.LAZY_LOAD;
  this.defaultZoneFile =
    this.loadingScheme == this.loadingSchemes.PRELOAD_ALL ?
      this.zoneFiles : 'northamerica';
  this.loadedZones = {};
  this.zones = {};
  this.rules = {};

  this.init = function (o) {
    var opts = { async: true };
    var sync = false;
    var def = this.defaultZoneFile;
    var parsed;
    // Override default with any passed-in opts
    for (var p in o) {
      opts[p] = o[p];
    }
    if (typeof def == 'string') {
      parsed = this.loadZoneFile(def, opts);
    }
    else {
      if (opts.callback) {
        throw new Error('Async load with callback is not supported for multiple default zonefiles.');
      }
      for (var i = 0; i < def.length; i++) {
        parsed = this.loadZoneFile(def[i], opts);
      }
    }
  };
  // Get the zone files via XHR -- if the sync flag
  // is set to true, it's being called by the lazy-loading
  // mechanism, so the result needs to be returned inline
  this.loadZoneFile = function (fileName, opts) {
    if (typeof this.zoneFileBasePath == 'undefined') {
      throw new Error('Please define a base path to your zone file directory -- timezoneJS.timezone.zoneFileBasePath.');
    }
    // ========================
    // Define your own transport mechanism here
    // and comment out the default below
    // ========================
    if (! this.loadedZones[fileName]) {
      this.loadedZones[fileName] = true;
      // return builtInLoadZoneFile(fileName, opts);
      return myLoadZoneFile(fileName, opts);
    }
  };
  this.loadZoneJSONData = function (url, sync) {
    var processData = function (data) {
      data = eval('('+ data +')');
      for (var z in data.zones) {
        _this.zones[z] = data.zones[z];
      }
      for (var r in data.rules) {
        _this.rules[r] = data.rules[r];
      }
    }
    if (sync) {
      var data = fleegix.xhr.doGet(url);
      processData(data);
    }
    else {
      fleegix.xhr.doGet(processData, url);
    }
  };
  this.loadZoneDataFromObject = function (data) {
    if (!data) { return; }
    for (var z in data.zones) {
      _this.zones[z] = data.zones[z];
    }
    for (var r in data.rules) {
      _this.rules[r] = data.rules[r];
    }
  };
  this.getAllZones = function() {
    var arr = [];
    for (z in this.zones) { arr.push(z); }
    return arr.sort();
  };
  this.parseZones = function(str) {
    var s = '';
    var lines = str.split('\n');
    var arr = [];
    var chunk = '';
    var zone = null;
    var rule = null;
    for (var i = 0; i < lines.length; i++) {
      l = lines[i];
      if (l.match(/^\s/)) {
        l = "Zone " + zone + l;
      }
      l = l.split("#")[0];
      if (l.length > 3) {
        arr = l.split(/\s+/);
        chunk = arr.shift();
        switch(chunk) {
          case 'Zone':
            zone = arr.shift();
            if (!_this.zones[zone]) { _this.zones[zone] = [] }
            _this.zones[zone].push(arr);
            break;
          case 'Rule':
            rule = arr.shift();
            if (!_this.rules[rule]) { _this.rules[rule] = [] }
            _this.rules[rule].push(arr);
            break;
          case 'Link':
            // No zones for these should already exist
            if (_this.zones[arr[1]]) {
              throw new Error('Error with Link ' + arr[1]);
            }
            // Create the link
            _this.zones[arr[1]] = arr[0];
            break;
          case 'Leap':
            break;
          default:
            // Fail silently
            break;
        }
      }
    }
    return true;
  };
  this.getTzInfo = function(dt, tz, isUTC) {
    // Lazy-load any zones not yet loaded
    if (this.loadingScheme == this.loadingSchemes.LAZY_LOAD) {
      // Get the correct region for the zone
      var zoneFile = getRegionForTimezone(tz);
      if (!zoneFile) {
        throw new Error('Not a valid timezone ID.');
      }
      else {
        if (!this.loadedZones[zoneFile]) {
          // Get the file and parse it -- use synchronous XHR
          var parsed = this.loadZoneFile(zoneFile, true);
        }
      }
    }
    var zone = getZone(dt, tz);
    var off = getBasicOffset(zone);
    // See if the offset needs adjustment
    var rule = getRule(dt, zone, isUTC);
    if (rule) {
      off = getAdjustedOffset(off, rule);
    }
    var abbr = getAbbreviation(zone, rule);
    return { tzOffset: off, tzAbbr: abbr };
  }
}



});

require.define("fs", function (require, module, exports, __dirname, __filename) {
    // nothing to see here... no file methods for the browser

});
